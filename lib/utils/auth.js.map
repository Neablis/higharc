{"version":3,"sources":["../../src/utils/auth.ts"],"names":["SALT_ROUNDS","ONE_HOUR","Math","floor","Date","now","createToken","user","token","jwt","sign","exp","email","admin","isAdmin","process","env","SECRET","parseToken","decoded","verify","hashPassword","password","bcrypt","hash","isPassword","Promise","success","error","compare","err","isMatch"],"mappings":";;;;;;;;;;;AAEA;;AACA;;AAEA,MAAMA,WAAW,GAAG,EAApB;AACA,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAiC,KAAK,EAAvD;;AAEO,MAAMC,WAAW,GAAIC,IAAD,IAAwB;AAC/C,MAAIC,KAAK,GAAGC,sBAAIC,IAAJ,CAAS;AACjBC,IAAAA,GAAG,EAAEV,QADY;AAEjBW,IAAAA,KAAK,EAAEL,IAAI,CAACK,KAFK;AAGjBC,IAAAA,KAAK,EAAEN,IAAI,CAACO;AAHK,GAAT,EAITC,OAAO,CAACC,GAAR,CAAYC,MAJH,CAAZ;;AAMA,SAAOT,KAAP;AACH,CARM;;;;AAUA,MAAMU,UAAU,GAAIV,KAAD,IAAiC;AACvD,MAAIW,OAAO,GAAGV,sBAAIW,MAAJ,CAAWZ,KAAX,EAAkBO,OAAO,CAACC,GAAR,CAAYC,MAA9B,CAAd;;AAEA,SAAOE,OAAP;AACH,CAJM;;;;AAMA,MAAME,YAAY,GAAG,MAAOC,QAAP,IAA6C;AACrE,SAAO,MAAMC,MAAM,CAACC,IAAP,CAAYF,QAAZ,EAAsBtB,WAAtB,CAAb;AACH,CAFM;;;;AAIA,MAAMyB,UAAU,GAAG,OAAOH,QAAP,EAAyBf,IAAzB,KAA2D;AACjF,SAAO,IAAImB,OAAJ,CAAY,CAACC,OAAD,EAAUC,KAAV,KAAoB;AACnC,QAAI,CAACrB,IAAL,EAAW,OAAOqB,KAAK,CAAC,cAAD,CAAZ;AAEXL,IAAAA,MAAM,CAACM,OAAP,CAAeP,QAAf,EAAyBf,IAAI,CAACe,QAA9B,EAAwC,CAACQ,GAAD,EAAMC,OAAN,KAAkB;AACtD,UAAID,GAAJ,EAASF,KAAK,CAACE,GAAD,CAAL;AAETH,MAAAA,OAAO,CAACI,OAAD,CAAP;AACH,KAJD;AAKH,GARM,CAAP;AASH,CAVM","sourcesContent":["import User from 'entity/User';\nimport { Context, Token } from 'types';\nimport jwt from 'jsonwebtoken';\nimport * as bcrypt from 'bcryptjs';\n\nconst SALT_ROUNDS = 10;\nconst ONE_HOUR = Math.floor(Date.now() / 1000) + (60 * 60)\n\nexport const createToken = (user: User): string => {\n    var token = jwt.sign({\n        exp: ONE_HOUR,\n        email: user.email,\n        admin: user.isAdmin\n    }, process.env.SECRET);\n\n    return token;\n}\n\nexport const parseToken = (token: string): Token | null => {\n    var decoded = jwt.verify(token, process.env.SECRET);\n\n    return decoded;\n}\n\nexport const hashPassword = async (password: string): Promise<string> => {\n    return await bcrypt.hash(password, SALT_ROUNDS);\n}\n\nexport const isPassword = async (password: string, user?: User): Promise<boolean> => {\n    return new Promise((success, error) => {\n        if (!user) return error('Missing user');\n\n        bcrypt.compare(password, user.password, (err, isMatch) => {\n            if (err) error(err)\n\n            success(isMatch);\n        });\n    });\n}"],"file":"auth.js"}