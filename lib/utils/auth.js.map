{"version":3,"sources":["../../src/utils/auth.ts"],"names":["SALT_ROUNDS","ONE_HOUR","Math","floor","Date","now","createToken","user","token","jwt","sign","exp","email","admin","isAdmin","userId","id","process","env","SECRET","parseToken","decoded","verify","hashPassword","password","bcrypt","hash","isPassword","Promise","success","error","compare","err","isMatch"],"mappings":";;;;;;;;;;;AAEA;;AACA;;AAEA,MAAMA,WAAW,GAAG,EAApB;AACA,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAiC,KAAK,EAAvD;;AAEO,MAAMC,WAAW,GAAIC,IAAD,IAAwB;AAC/C,QAAMC,KAAK,GAAGC,sBAAIC,IAAJ,CAAS;AACnBC,IAAAA,GAAG,EAAEV,QADc;AAEnBW,IAAAA,KAAK,EAAEL,IAAI,CAACK,KAFO;AAGnBC,IAAAA,KAAK,EAAEN,IAAI,CAACO,OAHO;AAInBC,IAAAA,MAAM,EAAER,IAAI,CAACS;AAJM,GAAT,EAKXC,OAAO,CAACC,GAAR,CAAYC,MALD,CAAd;;AAOA,SAAOX,KAAP;AACH,CATM;;;;AAWA,MAAMY,UAAU,GAAIZ,KAAD,IAAiC;AACvD,QAAMa,OAAO,GAAGZ,sBAAIa,MAAJ,CAAWd,KAAX,EAAkBS,OAAO,CAACC,GAAR,CAAYC,MAA9B,CAAhB;;AAEA,SAAOE,OAAP;AACH,CAJM;;;;AAMA,MAAME,YAAY,GAAG,MAAOC,QAAP,IAA6C;AACrE,SAAO,MAAMC,MAAM,CAACC,IAAP,CAAYF,QAAZ,EAAsBxB,WAAtB,CAAb;AACH,CAFM;;;;AAIA,MAAM2B,UAAU,GAAG,OAAOH,QAAP,EAAyBjB,IAAzB,KAA2D;AACjF,SAAO,IAAIqB,OAAJ,CAAY,CAACC,OAAD,EAAUC,KAAV,KAAoB;AACnC,QAAI,CAACvB,IAAL,EAAW,OAAOuB,KAAK,CAAC,cAAD,CAAZ;AAEXL,IAAAA,MAAM,CAACM,OAAP,CAAeP,QAAf,EAAyBjB,IAAI,CAACiB,QAA9B,EAAwC,CAACQ,GAAD,EAAMC,OAAN,KAAkB;AACtD,UAAID,GAAJ,EAASF,KAAK,CAACE,GAAD,CAAL;AAETH,MAAAA,OAAO,CAACI,OAAD,CAAP;AACH,KAJD;AAKH,GARM,CAAP;AASH,CAVM","sourcesContent":["import User from 'entity/User';\nimport { Context, Token } from 'types';\nimport jwt from 'jsonwebtoken';\nimport * as bcrypt from 'bcryptjs';\n\nconst SALT_ROUNDS = 10;\nconst ONE_HOUR = Math.floor(Date.now() / 1000) + (60 * 60)\n\nexport const createToken = (user: User): string => {\n    const token = jwt.sign({\n        exp: ONE_HOUR,\n        email: user.email,\n        admin: user.isAdmin,\n        userId: user.id\n    }, process.env.SECRET);\n\n    return token;\n}\n\nexport const parseToken = (token: string): Token | null => {\n    const decoded = jwt.verify(token, process.env.SECRET);\n\n    return decoded;\n}\n\nexport const hashPassword = async (password: string): Promise<string> => {\n    return await bcrypt.hash(password, SALT_ROUNDS);\n}\n\nexport const isPassword = async (password: string, user?: User): Promise<boolean> => {\n    return new Promise((success, error) => {\n        if (!user) return error('Missing user');\n\n        bcrypt.compare(password, user.password, (err, isMatch) => {\n            if (err) error(err)\n\n            success(isMatch);\n        });\n    });\n}"],"file":"auth.js"}